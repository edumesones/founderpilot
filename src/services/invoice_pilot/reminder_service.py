"""Reminder service for scheduling and managing invoice reminders."""

from datetime import datetime, timedelta
from typing import Optional
from uuid import UUID
import logging

from sqlalchemy.orm import Session

from src.models.invoice_pilot.invoice import Invoice, InvoiceReminder, InvoiceAction
from src.core.exceptions import NotFoundError, ValidationError

logger = logging.getLogger(__name__)


class ReminderService:
    """Service for handling invoice reminder operations."""

    # Default reminder schedule (days relative to due_date)
    # Negative = before due, Positive = after due
    DEFAULT_SCHEDULE = [-3, 3, 7, 14]  # 3 days before, then 3, 7, 14 days after

    def __init__(self, db: Session):
        self.db = db

    # --- Reminder Scheduling ---

    def schedule_reminders(
        self,
        invoice: Invoice,
        schedule: Optional[list[int]] = None,
    ) -> list[InvoiceReminder]:
        """
        Schedule reminders for an invoice based on due date and schedule.

        Args:
            invoice: The invoice to schedule reminders for
            schedule: List of days relative to due date (negative = before, positive = after)
                     If None, uses DEFAULT_SCHEDULE

        Returns:
            List of created InvoiceReminder objects
        """
        if schedule is None:
            schedule = self.DEFAULT_SCHEDULE

        reminders = []

        for days_offset in schedule:
            scheduled_date = invoice.due_date + timedelta(days=days_offset)
            scheduled_datetime = datetime.combine(
                scheduled_date, datetime.min.time().replace(hour=9)  # 9 AM
            )

            # Determine reminder type
            if days_offset < 0:
                reminder_type = "pre_due"
            elif days_offset == 3:
                reminder_type = "post_due_3d"
            elif days_offset == 7:
                reminder_type = "post_due_7d"
            elif days_offset == 14:
                reminder_type = "post_due_14d"
            else:
                reminder_type = f"post_due_{abs(days_offset)}d"

            # Check if reminder already exists
            existing = (
                self.db.query(InvoiceReminder)
                .filter(
                    InvoiceReminder.invoice_id == invoice.id,
                    InvoiceReminder.type == reminder_type,
                )
                .first()
            )

            if existing:
                logger.info(
                    f"Reminder {reminder_type} already exists for invoice {invoice.id}"
                )
                continue

            # Create reminder
            reminder = InvoiceReminder(
                invoice_id=invoice.id,
                scheduled_at=scheduled_datetime,
                type=reminder_type,
                status="pending",
                draft_message="",  # Will be generated by LLM later
            )

            self.db.add(reminder)
            reminders.append(reminder)

        if reminders:
            self.db.commit()
            logger.info(f"Scheduled {len(reminders)} reminders for invoice {invoice.id}")

        return reminders

    def get_reminder(
        self,
        reminder_id: UUID,
        invoice_id: Optional[UUID] = None,
    ) -> InvoiceReminder:
        """Get a reminder by ID with optional invoice check."""
        query = self.db.query(InvoiceReminder).filter(
            InvoiceReminder.id == reminder_id
        )

        if invoice_id:
            query = query.filter(InvoiceReminder.invoice_id == invoice_id)

        reminder = query.first()

        if not reminder:
            raise NotFoundError(f"Reminder {reminder_id} not found")

        return reminder

    def list_reminders_for_invoice(
        self,
        invoice_id: UUID,
        status: Optional[str] = None,
    ) -> list[InvoiceReminder]:
        """List all reminders for an invoice."""
        query = self.db.query(InvoiceReminder).filter(
            InvoiceReminder.invoice_id == invoice_id
        )

        if status:
            query = query.filter(InvoiceReminder.status == status)

        return query.order_by(InvoiceReminder.scheduled_at).all()

    def get_due_reminders(
        self,
        tenant_id: Optional[UUID] = None,
        before: Optional[datetime] = None,
    ) -> list[InvoiceReminder]:
        """
        Get reminders that are due to be sent.

        Args:
            tenant_id: Optional filter by tenant
            before: Optional cutoff time (default: now)

        Returns:
            List of reminders with status='pending' and scheduled_at <= before
        """
        if before is None:
            before = datetime.utcnow()

        query = (
            self.db.query(InvoiceReminder)
            .join(Invoice)
            .filter(
                InvoiceReminder.status == "pending",
                InvoiceReminder.scheduled_at <= before,
            )
        )

        if tenant_id:
            query = query.filter(Invoice.tenant_id == tenant_id)

        return query.order_by(InvoiceReminder.scheduled_at).all()

    # --- Reminder Actions ---

    def set_draft_message(
        self,
        reminder_id: UUID,
        draft_message: str,
    ) -> InvoiceReminder:
        """Set the draft message for a reminder (generated by LLM)."""
        reminder = self.get_reminder(reminder_id)

        reminder.draft_message = draft_message
        self.db.commit()
        self.db.refresh(reminder)

        logger.info(f"Set draft message for reminder {reminder_id}")
        return reminder

    def approve_reminder(
        self,
        reminder_id: UUID,
        approved_by: str,
        edited_message: Optional[str] = None,
    ) -> InvoiceReminder:
        """
        Approve a reminder for sending.

        Args:
            reminder_id: Reminder to approve
            approved_by: User ID who approved
            edited_message: Optional edited message (if user modified draft)
        """
        reminder = self.get_reminder(reminder_id)

        if reminder.status != "pending":
            raise ValidationError(
                f"Cannot approve reminder with status {reminder.status}"
            )

        reminder.status = "approved"
        reminder.approved_by = approved_by

        if edited_message:
            reminder.final_message = edited_message
        else:
            reminder.final_message = reminder.draft_message

        self.db.commit()
        self.db.refresh(reminder)

        # Log action
        self._log_action(
            invoice_id=reminder.invoice_id,
            action_type="reminder_approved",
            actor=approved_by,
            details={
                "reminder_id": str(reminder_id),
                "reminder_type": reminder.type,
                "edited": edited_message is not None,
            },
        )

        logger.info(f"Approved reminder {reminder_id}")
        return reminder

    def edit_reminder(
        self,
        reminder_id: UUID,
        edited_message: str,
        edited_by: str,
    ) -> InvoiceReminder:
        """
        Edit a reminder message (creates edited version, still needs approval).

        Args:
            reminder_id: Reminder to edit
            edited_message: New message content
            edited_by: User ID who edited
        """
        reminder = self.get_reminder(reminder_id)

        if reminder.status not in ["pending", "approved"]:
            raise ValidationError(
                f"Cannot edit reminder with status {reminder.status}"
            )

        reminder.final_message = edited_message

        # If was approved, keep it approved with new message
        # If was pending, keep it pending
        self.db.commit()
        self.db.refresh(reminder)

        # Log action
        self._log_action(
            invoice_id=reminder.invoice_id,
            action_type="reminder_edited",
            actor=edited_by,
            details={
                "reminder_id": str(reminder_id),
                "reminder_type": reminder.type,
            },
        )

        logger.info(f"Edited reminder {reminder_id}")
        return reminder

    def skip_reminder(
        self,
        reminder_id: UUID,
        skipped_by: str,
        reason: Optional[str] = None,
    ) -> InvoiceReminder:
        """Skip a reminder (won't be sent)."""
        reminder = self.get_reminder(reminder_id)

        if reminder.status == "sent":
            raise ValidationError("Cannot skip a reminder that was already sent")

        reminder.status = "skipped"
        self.db.commit()
        self.db.refresh(reminder)

        # Log action
        self._log_action(
            invoice_id=reminder.invoice_id,
            action_type="reminder_skipped",
            actor=skipped_by,
            details={
                "reminder_id": str(reminder_id),
                "reminder_type": reminder.type,
                "reason": reason,
            },
        )

        logger.info(f"Skipped reminder {reminder_id}")
        return reminder

    def mark_as_sent(
        self,
        reminder_id: UUID,
        sent_by: str = "agent",
    ) -> InvoiceReminder:
        """Mark a reminder as sent."""
        reminder = self.get_reminder(reminder_id)

        if reminder.status != "approved":
            raise ValidationError(
                f"Cannot mark reminder as sent with status {reminder.status}. Must be approved first."
            )

        reminder.status = "sent"
        reminder.sent_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(reminder)

        # Log action
        self._log_action(
            invoice_id=reminder.invoice_id,
            action_type="reminder_sent",
            actor=sent_by,
            details={
                "reminder_id": str(reminder_id),
                "reminder_type": reminder.type,
                "sent_at": reminder.sent_at.isoformat(),
            },
        )

        logger.info(f"Marked reminder {reminder_id} as sent")
        return reminder

    def mark_response_received(
        self,
        reminder_id: UUID,
    ) -> InvoiceReminder:
        """Mark that client responded to reminder."""
        reminder = self.get_reminder(reminder_id)

        reminder.response_received = True
        self.db.commit()
        self.db.refresh(reminder)

        logger.info(f"Marked reminder {reminder_id} as responded")
        return reminder

    # --- Reminder History ---

    def get_reminder_history(
        self,
        invoice_id: UUID,
    ) -> list[InvoiceReminder]:
        """Get full reminder history for an invoice."""
        return (
            self.db.query(InvoiceReminder)
            .filter(InvoiceReminder.invoice_id == invoice_id)
            .order_by(InvoiceReminder.scheduled_at)
            .all()
        )

    def count_sent_reminders(
        self,
        invoice_id: UUID,
    ) -> int:
        """Count how many reminders have been sent for an invoice."""
        return (
            self.db.query(InvoiceReminder)
            .filter(
                InvoiceReminder.invoice_id == invoice_id,
                InvoiceReminder.status == "sent",
            )
            .count()
        )

    # --- Helpers ---

    def _log_action(
        self,
        invoice_id: UUID,
        action_type: str,
        actor: str,
        details: dict,
    ) -> InvoiceAction:
        """Log an action in the invoice audit trail."""
        action = InvoiceAction(
            invoice_id=invoice_id,
            action_type=action_type,
            actor=actor,
            details=details,
            timestamp=datetime.utcnow(),
        )
        self.db.add(action)
        self.db.commit()
        return action
